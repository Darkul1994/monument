<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>monument: a high performance, high security, node application server</title>

    <link rel="stylesheet" href="fonts/fonts.css">
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
      <header>
        <h1>monument</h1>
        <p>A fast, light secure event driven node server.</p>

        <p class="view"><a href="https://github.com/ansble/monument">View the Project on GitHub <small>ansble/monument</small></a></p>


        <ul class="button-links">
          <li class="button-links__item"><a href="https://github.com/ansble/monument/zipball/master" class="button-links__item__link">Download <strong>ZIP File</strong></a></li>
          <li class="button-links__item"><a href="https://github.com/ansble/monument/tarball/master" class="button-links__item__link">Download <strong>TAR Ball</strong></a></li>
          <li class="button-links__item"><a href="https://github.com/ansble/monument" class="button-links__item__link">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <p>Monument doesn't just facilitate dealing with events; it fully embraces an event driven programming model. It does everything through events. Everything.</p>

        <p>Data is passed through events, routes are handled through events, and things are logged through events.</p>

        <h2>Use it</h2>
        <p>
          <h4>Use NPM!</h4>
          <code>npm install --save monument</code>
        </p>
        <p>
          <h4>Use the CLI tools!</h4>
          <code>npm install -g monument-cli</code>
          <p>Then you can do <code>monument new &lt;path to project&gt;</code> to lay down new projects and a bunch more. Check out the <a href="https://github.com/ansble/monument-cli">docs over here</a></p>
        </p>

        <h2>
        <a id="some-features" class="anchor" href="#some-features" aria-hidden="true"><span class="octicon octicon-link"></span></a>Some features:</h2>

        <ul>
          <li>resource pooling - This is not connection pooling, this is resource pooling, where a thousand pages asking for the same data from the database at the same time result in one request to the database instead of a thousand. Or ten thousand. If a request comes in requesting the same data before the database responds it simple waits until the data comes back from the DB like whoever initiated the call to the DB to begin with.</li>
          <li>isomorphic routing - The routing is completely event based, this means that a route document (JSON) can be shared between the server side code and the front end code, allowing true isomorphic routing. Handlers can be shared as well... but since they likely are a little different in their needs that might not be as common as we would like.</li>
        </ul>
      </section>
<section>
  <h2>Building your first application</h2>
  <p>This is a quick walk through of building a simple application with monument that will get you from nothing to up and running. So here we go!</p>
  <h3>Install the CLI tools</h3>
  <p>The CLI tools are designed to automate many of the redundant tasks in the workflow for building a monument application. So you're going to want to grab them right up front. <code>npm install -g monument-cli</code>.</p>
  <h3>Create your project base</h3>
  <p>First create a folder for your project, then navigate a terminal (cmd) into it. A quick <code>monument new &lt;path to project&gt;</code> will generate a basic project with stubbed tests, basic error handlers, and an index route, everything you need to knock out an application fast.</p>
  <a href="https://camo.githubusercontent.com/a5cf95e1150d2760ec8760ac8ef9812f0f562e2e/687474703a2f2f672e7265636f726469742e636f2f457762544f37784467792e676966" target="_blank"><img src="https://camo.githubusercontent.com/a5cf95e1150d2760ec8760ac8ef9812f0f562e2e/687474703a2f2f672e7265636f726469742e636f2f457762544f37784467792e676966" alt="getting started with monument gif" data-canonical-src="http://g.recordit.co/EwbTO7xDgy.gif" style="max-width:100%;"></a>
  <p>Watch the slightly longer <a href="http://recordit.co/EwbTO7xDgy">video version here.</a><br><br>It is also the easiest way to add routes and data handlers!</p>
  <p>Your project should now look like this:</p>
  <pre><code>    project/
        routes/
            main.js
        templates/
            main.jst
        .bowerrc
        .editorconfig
        .jshintrc
        README.md
        app.js
        bower.json
        package.json
        routes.json
</code></pre>
<h3>Create your routes</h3>
<p>Creating routes is a pain generally. Thanks to the decoupled way that monument applications are created we can take all the pain out of it.</p>
<p>The routes.json file contains all the allowed routes and their verbs inside it. (It is also served up from /routes on your server so the front end can consume it easily) The base routes.json looks like this when you open it:</p>
<pre><code>
  {
    "/": ["get"]
  }
</code></pre>
<p>Adding routes is simple. We'll look at two examples, an about page and a profile page. The about page will only eer be accessed with a GET verb so adding it consists of adding <code>"/about": ["get"]</code> to our obejct. The profile page is going to be a little more complicated, so here are the changes and then we'll discuss them.</p>
<pre><code>
  {
    "/": ["get"]
    , "/about": ["get"]
    , "/profile": ["get", "post"]
    , "/profile/:id": ["get", "put", "delete"]
  }
</code></pre>
<p>The first <code>/profile</code> accepts both <code>get</code> and <code>post</code> so that you can open a blank profile and then post a new profile to be added to the collection. The <code>/profile/:id</code> is a wildcard route. Anything that lands in the <code>:id</code> slot will be added to the request <code>params</code> as a variable named <code>id</code>. This should feel fairly familiar, hopefully. That URL is then allowed to have <code>put</code> for updates, <code>get</code> for viewing, and <code>delete</code> for removal.</p>
<p>The last step in adding route is to use the CLI to stub out the handlers for each route. A quick <code>yo monument-cli:routes</code> lays down stubs for any route/verb combination that has not yet been created in the <code>/routes</code> folder. It creates a file for each toplevel route and adds the sub route handlers to it.</p>
<p>This process can also be used to stub out new route handlers instead of writing them by hand throughout project development</p>
<h3>Write your first route handler</h3>
<p>Once you have laid down your route stubs they will all basically look like this:</p>
<pre><code>
  events.on('route:/profile:get', function (connection) {
    connection.res.send('route /profile now responding to get requests');
    // If those more familiar with using ".end()" when finishing
    // eventhandlers it is also available as an alternative,
    // like this:
    // connection.res.end('route /profile now responding to get requests');
  });
</code></pre>
<h4>The route event</h4>
<p>Route events are structured like this: <code>route:PATH:VERB</code> and are triggered by the routing code. All you have to do is respond to them. The function that handles the route recieves a connection object that has 5 properties:</p>
<ul>
  <li><b>req</b>:</li>
  <li><b>res</b>: The Request and Response, making it easy to access request variables and respond correctly to the request</li>
  <li><b>query</b>: An object containing query params</li>
  <li><b>body</b>: An object containing the body of the request</li>
  <li><b>params</b>: An object containing the URL parameters</li>
</ul>
<h4>An important thought...</h4>
<p>You can do anything you need to within the function passed to <code>events.on</code> but you should avoid adding permenant event listeners. Pretty much any event listening that needs to happen inside of the handler should be <code>events.once</code>. This is because each instance of that handler corresponds to a single request and once you are done with that request all the events need to be unbound or they will eventually eat up your memory footprint.</p>
<p>So either manually unbind them or use the built in <code>events.once</code> as it will unbind itself after the first time it triggers.</p>
</section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/ansble">ansble llc</a></p>
        <p><small>Hosted on GitHub Pages &mdash;</small></p>
      </footer>
  </body>
</html>
